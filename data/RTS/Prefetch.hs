{-# language DerivingVia #-}
module RTS.Prefetch where

{- | Prefetch operations: Note how every prefetch operation has a name with the pattern prefetch*N#, where N is either 0,1,2, or 3.

This suffix number, N, is the "locality level" of the prefetch, following the convention in GCC and other compilers. Higher locality numbers correspond to the memory being loaded in more levels of the cpu cache, and being retained after initial use. The naming convention follows the naming convention of the prefetch intrinsic found in the GCC and Clang C compilers.

On the LLVM backend, prefetch*N# uses the LLVM prefetch intrinsic with locality level N. The code generated by LLVM is target architecture dependent, but should agree with the GHC NCG on x86 systems.

On the PPC native backend, prefetch*N is a No-Op.

On the x86 NCG, N=0 will generate prefetchNTA, N=1 generates prefetcht2, N=2 generates prefetcht1, and N=3 generates prefetcht0.

For streaming workloads, the prefetch*0 operations are recommended. For workloads which do many reads or writes to a memory location in a short period of time, prefetch*3 operations are recommended.

For further reading about prefetch and associated systems performance optimization, the instruction set and optimization manuals by Intel and other CPU vendors are excellent starting place.

The "Intel 64 and IA-32 Architectures Optimization Reference Manual" is especially a helpful read, even if your software is meant for other CPU architectures or vendor hardware. The manual can be found at http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html .

The prefetch* family of operations has the order of operations determined by passing around the State# token.

To get a "pure" version of these operations, use inlinePerformIO which is quite safe in this context.

It is important to note that while the prefetch operations will never change the answer to a pure computation, They CAN change the memory locations resident in a CPU cache and that may change the performance and timing characteristics of an application. The prefetch operations are marked has_side_effects=True to reflect that these operations have side effects with respect to the runtime performance characteristics of the resulting code. Additionally, if the prefetchValue operations did not have this attribute, GHC does a float out transformation that results in a let/app violation, at least with the current design. -}
class Prefetch s (a ∷ T r) where
  -- | Prefetch to locality 0 (LLVM).
  --
  --  NTA (non-temporal data with respect to all cache levels) — prefetch data into non-temporal cache structure and into a location close to the processor, minimizing cache pollution. 
  --
  --  Recommended for streaming workloads.
  nta ∷ a → ST_ s
  -- | Prefetch to locality 1 (LLVM).
  --
  --  T2 (temporal data with respect to second level cache misses) — prefetch data into level 3 cache and higher, or an implementation-specific choice.
  --
  --  Recommended for streaming workloads.
  t2 ∷ a → ST_ s
  -- | Prefetch to locality 2 (LLVM).
  --
  -- T1 (temporal data with respect to first level cache misses)—prefetch data into level 2 cache and higher.
  t1 ∷ a → ST_ s
  -- | Prefetch to locality 3 (LLVM).
  --
  -- T0 (temporal data)—prefetch data into all levels of the cache hierarchy.
  --
  -- Recommended for workloads which do many reads or writes to a memory location in a short period of time.
  t0 ∷ a → ST_ s

-- | W/ Byte Offset
instance Prefetch s (# Addr#, I #) where
  nta (# x, i #) = prefetchAddr0# x i
  t2 (# x, i #) = prefetchAddr1# x i
  t1 (# x, i #) = prefetchAddr2# x i
  t0 (# x, i #) = prefetchAddr3# x i
instance Prefetch s Addr# where
  nta = (`prefetchAddr0#` 0#)
  t2 = (`prefetchAddr1#` 0#)
  t1 = (`prefetchAddr2#` 0#)
  t0 = (`prefetchAddr3#` 0#)
deriving via (# Addr#, I #) instance Prefetch s (# ForeignArray# x, I #)
deriving via (# Addr#, I #) instance Prefetch s (# ForeignMutableArray# s x, I #)
deriving newtype instance Prefetch s (ForeignArray# x)
deriving newtype instance Prefetch s (ForeignMutableArray# s x)

instance Prefetch s (# ByteArray#, I #) where
  nta (# x, i #) = prefetchByteArray0# x i
  t2 (# x, i #) = prefetchByteArray1# x i
  t1 (# x, i #) = prefetchByteArray2# x i
  t0 (# x, i #) = prefetchByteArray3# x i
instance Prefetch s ByteArray# where
  nta = (`prefetchByteArray0#` 0#)
  t2 = (`prefetchByteArray1#` 0#)
  t1 = (`prefetchByteArray2#` 0#)
  t0 = (`prefetchByteArray3#` 0#)
deriving via (# ByteArray#, I #) instance Prefetch s (# PinnedArray# x, I #)
deriving via (# ByteArray#, I #) instance Prefetch s (# UnboxedArray# x, I #)
deriving newtype instance Prefetch s (PinnedArray# x)
deriving newtype instance Prefetch s (UnboxedArray# x)
instance Prefetch s (# MutableByteArray# s, I #) where
  nta (# x, i #) = prefetchMutableByteArray0# x i
  t2 (# x, i #) = prefetchMutableByteArray1# x i
  t1 (# x, i #) = prefetchMutableByteArray2# x i
  t0 (# x, i #) = prefetchMutableByteArray3# x i
instance Prefetch s (MutableByteArray# s) where
  nta = (`prefetchMutableByteArray0#` 0#)
  t2 = (`prefetchMutableByteArray1#` 0#)
  t1 = (`prefetchMutableByteArray2#` 0#)
  t0 = (`prefetchMutableByteArray3#` 0#)
deriving via (# MutableByteArray# s, I #) instance Prefetch s (# UnboxedMutableArray# s x, I #)
deriving newtype instance Prefetch s (PinnedMutableArray# s x)
deriving newtype instance Prefetch s (UnboxedMutableArray# s x)
deriving via (# MutableByteArray# s, I #) instance Prefetch s (# PinnedMutableArray# s x, I #)
instance Prefetch s a where
  nta = prefetchValue0#
  t2 = prefetchValue1#
  t1 = prefetchValue2#
  t0 = prefetchValue3#
